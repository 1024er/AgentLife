/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/Animated Woman.glb -o src/components/AnimatedWoman.jsx -r public
*/

import { Html, useAnimations, useGLTF, useFBX } from "@react-three/drei";
import { useFrame, useGraph } from "@react-three/fiber";
import { atom, useAtom } from "jotai";
import React, { useEffect, useMemo, useRef, useState } from "react";
import { SkeletonUtils } from "three-stdlib";
import { useGrid } from "../hooks/useGrid";
import { socket, selectedAvatarAtom, charactersAtom } from "./SocketManager";

import { motion } from "framer-motion-3d";

const MOVEMENT_SPEED = 3;
export const conversationHistoryAtom = atom([]);
export const onWatchNumAtom = atom(0);

export function Avatar({
  id,
  avatarName = "coder",
  ...props
}) {
  const [selectedAvatar, setSelectedAvatar] = useAtom(selectedAvatarAtom);
  const [chatMessage, setChatMessage] = useState("");
  const position = useMemo(() => props.position, []);
  
  const [characters, setCharacters] = useAtom(charactersAtom);
  const [onWatchNum, setOnWatchNum] = useAtom(onWatchNumAtom);
  
  const avatar = useRef();
  const [path, setPath] = useState();
  const [lookAt, setLookAt] = useState([]);
  const { gridToVector3 } = useGrid();

  const group = useRef();

  const file_name = `models/${avatarName}.glb`;
  const { scene } = useGLTF(file_name);
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);

  const { animations: walkAnimation } = useFBX(
    "/animations/Walking.fbx"
  );
  walkAnimation[0].name = "Walking";
  
  const { animations: idleAnimation } = useFBX(
    "/animations/Idle.fbx"
  );
  idleAnimation[0].name = "Idle";

  const { animations: talkingAnimation } = useFBX(
    "/animations/Talking.fbx"
  );
  talkingAnimation[0].name = "Talking";

  const { animations: textingAnimation } = useFBX(
    "animations/Texting.fbx"
  );
  textingAnimation[0].name = "Texting";

  const { animations: sleepingAnimation } = useFBX(
    "animations/Sleeping.fbx"
  );
  sleepingAnimation[0].name = "Sleeping";

  const { animations: cookingAnimation } = useFBX(
    "animations/Cooking.fbx"
  );
  cookingAnimation[0].name = "Cooking";

  const { animations: codingAnimation } = useFBX(
    "animations/Coding.fbx"
  );
  codingAnimation[0].name = "Coding";

  const { actions } = useAnimations(
    [
      walkAnimation[0], 
      idleAnimation[0], 
      talkingAnimation[0],
      textingAnimation[0],
      sleepingAnimation[0],
      cookingAnimation[0],
      codingAnimation[0]
    ],
    avatar
  ); 

  const [animation, setAnimation] = useState("Idle");
  const [init, setInit] = useState(false);
  const [showChatBubble, setShowChatBubble] = useState(false);
  const [conversationHistory, setConversationHistory] = useAtom(conversationHistoryAtom);

  useEffect(() => {
    clone.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });
  }, [clone]);

  useEffect(() => {
    if (actions[animation]) {
      actions[animation]
        .reset()
        .fadeIn(init ? 0.32 : 0)
        .play();
      setInit(true);
    } else {
      console.error(`Animation ${animation} not found in actions: ${actions}.`);
    }
    return () => actions[animation]?.fadeOut(0.32);
  }, [animation, avatarName]);

  useEffect(() => {

    function onUpdateState(value) {
      // console.log("value", value);
      if (value.character.id === id) {
        
        setOnWatchNum(value.on_watch_num);

        setCharacters((prev) => {
          const newCharacters = [...prev];
          const character = newCharacters.find((c) => c.id === id);
          Object.assign(character, value.character);
          return newCharacters;
        });

        if (value.character.event.type === "move") {
          const path = [];
          value.character.path?.forEach((gridPosition) => {
            path.push(gridToVector3(gridPosition));
          });
          setPath(path);
          setLookAt(gridToVector3(value.character.look_at));
        }

        if (value.character.event.type === "talk") {
          const newConversation = { [`[${new Date().toLocaleTimeString()}] ${value.character.name}`]: "è¯´ï¼š" + value.character.event.type };
          const updatedHistory = [...conversationHistory, newConversation];

          if (updatedHistory.length > 30) {
            updatedHistory.shift();
          }

          setConversationHistory(updatedHistory);
        }
        else {
          const newConversation = { [`[${new Date().toLocaleTimeString()}] ${value.character.name}`]: "é€‰æ‹©ï¼š" + value.character.event.type };
          const updatedHistory = [...conversationHistory, newConversation];

          if (updatedHistory.length > 30) {
            updatedHistory.shift();
          }
          
          setConversationHistory(updatedHistory);
        };
      }
    }

    socket.on("updateState", onUpdateState);
    
    return () => {
      socket.off("updateState", onUpdateState);
    };
  }, [id, characters, conversationHistory]);

  useFrame((_state, delta) => {

    // console.log(characters)
    
    if (path?.length && group.current.position.distanceTo(path[0]) > 0.1) {
      const direction = group.current.position
        .clone()
        .sub(path[0])
        .normalize()
        .multiplyScalar(MOVEMENT_SPEED * delta);
      group.current.position.sub(direction);
      group.current.lookAt(path[0]);
      setAnimation("Walking");
    } 
    
    else if (path?.length) {
      path.shift();
      setCharacters((prev) => {
        const newCharacters = [...prev];
        const character = newCharacters.find((c) => c.id === id);
        character.position = {
          x: Math.round(group.current.position.x),
          z: Math.round(group.current.position.z),
        };
        character.position = `${Math.round(group.current.position.x)},${Math.round(group.current.position.z)}`;
        return newCharacters;
      });
    } 
    
    else {
      if (lookAt?.length) {
        group.current.lookAt(lookAt);
      }

      let chatMessageBubbleTimeout;
      const cur_character = characters.find((c) => c.id === id);
      
      if (cur_character.state === "sleeping") {
        setChatMessage("zzzZZZ");
        setShowChatBubble(true);
      }

      else if (cur_character.state === "reading") {
        setAnimation("Texting");
        setChatMessage("ðŸ“±");
        setShowChatBubble(true);
      }

      else if (cur_character.state === "searching") {
        setAnimation("Texting");
        setChatMessage("ðŸ”");
        setShowChatBubble(true);
      }

      else if (cur_character.state === "cooking") {
        setAnimation("Cooking");
        setChatMessage("ðŸ§‘â€ðŸ³ " + "æ­£åœ¨åšï¼š" + cur_character.event.message);
        setShowChatBubble(true);
      }

      else if (cur_character.state === "posting") {
        setAnimation("Texting");
        setChatMessage("ðŸ’¬ å‘å¸ƒäº†ä¸€æ¡å¾®åš");
        setShowChatBubble(true);
      }

      else if (cur_character.state === "checking") {
        setAnimation("Texting");
        setChatMessage("ðŸ“ æŸ¥çœ‹å¾®åšè¯„è®ºä¸­");
        setShowChatBubble(true);
      }

      else if (cur_character.state === "replying") {
        setAnimation("Texting");
        setChatMessage("â†©ï¸ å›žå¤å¾®åšè¯„è®º");
        setShowChatBubble(true);
      }

      else if (cur_character.state === "coding") {
        setAnimation("Coding");
        setChatMessage("ðŸ’» Coding");
        setShowChatBubble(true);
      }

      else if (cur_character.event.type === "talk") {
        setAnimation("Talking");
        setChatMessage(cur_character.event.message);
        
        clearTimeout(chatMessageBubbleTimeout);
        setShowChatBubble(true);
        chatMessageBubbleTimeout = setTimeout(() => {
          setShowChatBubble(false);
        }, 5000);
      }

      else {
        setChatMessage("");
        setAnimation("Idle");
        setShowChatBubble(false);
      }
    }
  });

  useEffect(() => {
    function handleKeyDown(event) {
      if (event.key === "Escape") {
        setSelectedAvatar(null); 
      }
    }

    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);

  if (!nodes || !materials) {
    return null;
  }

  return (
    <group
      ref={group}
      {...props}
      position={position}
      dispose={null}
      name={`character-${id}`}
      onClick={() => {setSelectedAvatar(id);}}
    >
      <Html position-y={2}>
        <div className="w-60 max-w-full">
          <p
            className={`absolute max-w-full font-light break-words -translate-y-full p-2 -translate-x-1/2 rounded-lg bg-black bg-opacity-10 backdrop-blur-sm text-slate-200 text-sm transition-opacity overflow-y-auto duration-500 ${
              showChatBubble ? "" : "opacity-0"
            }`}
          >
            {chatMessage}
          </p>
        </div>
      </Html>
      <motion.group
        initial={{
          y: 3,
          rotateY: Math.PI * 4,
          scale: 0,
        }}
        animate={{
          y: 0,
          rotateY: 0,
          scale: 1,
        }}
        transition={{
          delay: 0.8,
          mass: 5,
          stiffness: 200,
          damping: 42,
        }}
      >
        <primitive object={clone} ref={avatar} />
        <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
        <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
        <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
        <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
        <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
        <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
        <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
        <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} />
        <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
      </motion.group>
    </group>
  );
}


useGLTF.preload("/models/coder.glb");
useGLTF.preload("/models/designer.glb");
useGLTF.preload("/animations/Talking.fbx");
useGLTF.preload("/animations/Walking.fbx");
useGLTF.preload("/animations/Idle.fbx");
useFBX.preload("/animations/Texting.fbx");
useFBX.preload("/animations/Sleeping.fbx");
useFBX.preload("/animations/Cooking.fbx");
useFBX.preload("/animations/Coding.fbx");